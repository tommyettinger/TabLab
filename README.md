# TabLab
A tool that generates Java source code from tab-separated value files, such as those from spreadsheets.

First off, TabLab probably doesn't have much application for most people. It's meant for cases where a lot of data needs
to be entered in a convenient manner, then exported so that Java can read it without involving any 3rd-party libraries.
If you don't like working with spreadsheets for data entry, or your data is highly-relational and would work better with
a SQL-like database than a only-slightly-relational spreadsheet, then you may want to look into alternatives that fit
your usage. But if you have some case where there are many fields, all strongly-typed, and you don't want to enter large
amounts of boilerplate to make the data usable, TabLab may come in handy. It has some extra features that may "sweeten
the deal," like being able to have one cell of a spreadsheet (that is, one string with no tabs in it, corresponding to a
single row and column) refer to an array of items with a certain type, or even a Map of keys to values (with keys and
values potentially having different types). It generates normal Java source code, with the only runtime dependency
beyond the data files being a two-method "library" file also generated to allow Map cells to be conveniently used. Even
that micro-library file isn't necessary if you already use [SquidLib](https://github.com/SquidPony/SquidLib), since
TabLab has an option to generate OrderedMap files using that class from SquidLib's collections, instead of the default
LinkedHashMap from the JDK. Other widely-used collections may get support as well.

## Usage

Typically, you don't need to build TabLab, and can use the runnable .jar file or the Windows .bat files that wrap that
.jar. Most of the instructions to TabLab are in the input files themselves, rather than given at the command line.
Currently, the only input that TabLab takes on the command line consists of the file name of the input file to process,
and optionally the text `--SquidLib` (which is case-insensitive) to generate code that uses SquidLib collections instead
of JDK ones. Within the input file, the syntax is mostly that rows are separated by newlines (Unix or Win32 conventions
both work), and the cells of each row are separated by tabs.

The first part of the input file is a top line that determines what Java package and class name to write the output to,
followed by an optional cell that has the name of a "key column" that will contain keys in a generated map, with each
key corresponding to one of the rows of data. This top line looks like:

```
com.example.some.game.Job	name
```

In this, the package is `com.example.some.game`, the Java file and class that will be written into that package is
`Job.java`, and the name of the column to use as a key is `name`. There is only one tab; the package and class are
written as they would be in a Java import. The type of the column isn't entered here, but it should be String (the
default) in the next section. The key column is optional, but using it is recommended; it allows this TabLab class to be
referenced from other TabLab classes in the same package.

After this is header line, containing the column names and types, one cell per column. This means both name and type
are in the same cell; they are separated by a colon, `:`. Supported "basic" types are:
  - `String`, referring to `java.lang.String`
    - This is the default if no type at all is specified for a column, when no colon is present.
    - It can also be written with the aliases `str` and `s`.
  - `boolean`, the primitive true-or-false type; this will be boxed if used in a map.
    - It can also be written with the aliases `bool` and `b`.
  - `char`, the primitive character type; this will be boxed if used in a map.
    - It can also be written with the alias `c`.
  - `int`, the primitive 32-bit integer type; this will be boxed if used in a map.
    - It can also be written with the alias `i`.
  - `long`, the primitive 64-bit integer type; this will be boxed if used in a map.
    - It can also be written with the alias `l`; be careful that this isn't mistaken for another symbol, like `1`.
  - `float`, the primitive 32-bit floating-point type; this will be boxed if used in a map.
    - It can also be written with the alias `f`.
  - `double`, the primitive 64-bit floating-point type; this will be boxed if used in a map.
    - It can also be written with the alias `d`.
  - Any class generated by TabLab in the same package, as long as the other class has a key column.
    - The type here should be just the class section of the top line, such as `Job`, not `com.example.some.game.Job`.

In addition to this, there are some "group" types with multiple values in one cell, with the boundary between values
specified in the name of the type. The boundary is meant to be adapted to fit whatever data you have, so if you have
String values separated by a comma and a space in a list inside a cell, you could use `, ` as the separator in an array
type. This would look like `String[, ]` as the type. You could also use String as the type if you want to parse it
yourself, or if you have some especially complicated case in each cell. Supported "group" types are:

  - Arrays containing items of a basic type (one type per array).
    - These are written with the basic type's name or alias, followed immediately by square brackets with the boundary
      inside those brackets.
    - This looks like `String[ ]` for space-separated Strings, or `i[;;]` for ints separated by two semicolons.
    - When you write an array value, you separate each basic item in it with the boundary. In the first example given,
      with the type `String[ ]`, this would look like `Bill Bob Carl Joe` to produce a 4-element array of Strings.
  - Maps containing keys of a basic type and values of a possibly-different basic type (one key type, one value type).
    - These are written with the key type's name or alias, followed immediately by curly braces with the boundary inside
      those braces, and immediately after that the value type's name or alias.
    - This looks like `String{, }double` for maps with String keys and Double values (the doubles become boxed in maps)
      separated by comma and space, or `i{ }s` for maps with Integer keys and String values separated by space.
    - When you write a map value, you separate each key and each value in it with the boundary. In the first example
      given, with the type `String{, }double`, this would look like `Bill, 2.3, Bob, 4.2, Carl, 3.14, Joe, 9999` to
      produce a map with 4 key-value pairs.

An example header line looks like:

```
name	description	offense:int	defense:int	talents:Talent[;;]	skills:str{,}int
``

Here, name and description are String type because no type is specified, offense and defense are int type, talents is an
array of Talent values (where Talent is expected to be made by TabLab at some point before this class is compiled)
separated by double semicolons, and skills is a map of String keys to int values, separated by commas. Since the top
line specified name as the key column, this `Job` class could be used from other TabLab data, where a row would be
referenced by a (unique) value in the name column here.

After the header line, it's just filling as many rows as you need with data that matches the types in the header.
With the header above, a row of that data could look like:

```
Ninja	A nimble assassin	9	1	Poison;;Martial Arts	Vanish,2,Smoke Bomb,1,Shadow Dagger,2
```

This makes the name (and so the key) `Ninja`, the description `A nimble assassin`, the offense value `9`, the defense
value `1`, the Talents array references to two talents called `Poison` and `Martial Arts`, and the skills map consisting
of `Vanish` mapped to `2`, `Smoke Bomb` mapped to `1`, and `Shadow Dagger` mapped to `2`.

OK, enjoy!